#!/usr/bin/perl
use strict;
use warnings;

sub main
{
	my $db_guard = database->guard();
	my $db = $database::db;

	$db->{counter}++;
	$db->{debug} = 2;
	$db->{file} = {
		time => file::update_time("makeless"),
		digest => file::digest("makeless"),
	};
	print $db->{test}, " -> ", $db->{counter}, "\n";

	print $db, "\n" if $db->{debug};
}

package database
{
	our $db;

	my $defaults = {
		counter => 0,
		test => "hello world",
		debug => 0,	# 0: no; 1: dump database; 2: 1 with base64 digest
	};

	sub guard
	{
		$db = database::default(raii::db->new("data"));
		bless {}, shift;
	}

	sub DESTROY { undef $db }

	sub default
	{
		my $db = shift;
		my $dvals = shift || $defaults;
		foreach (keys %$dvals) {
			$db->{$_} = $dvals->{$_} unless exists $db->{$_};
			&default($db->{$_}, $dvals->{$_}) if ref($db->{$_}) eq 'HASH'
		}
		$db;
	}

	sub reset
	{
		my $db = shift;
		&default($db->reset())
	}
}

package file
{
	sub update_time
	{
		my $path = shift;
		(stat $path)[9];
	}

	sub digest
	{
		my $path = shift;
		if ($database::db->{debug} > 1) {
			use Digest::file qw(digest_file_base64);
			digest_file_base64($path, "MD5");
		}
		else {
			use Digest::file qw(digest_file);
			digest_file($path, "MD5");
		}
	}
}

package raii::db
{
	use Storable qw(fd_retrieve store);
	use Data::Dumper;
	$Data::Dumper::Sortkeys = 1;

	my $config_key = 'raii::db::config';

	sub new
	{
		my $class = shift;
		my $path = shift;

		my $db = _load($path);
		bless($db, $class)->_config({ path => $path });
	}

	sub DESTROY
	{
		my $db = shift;
		$db->save();
		print "raii::db -> saved.\n";
	}

	sub save
	{
		my $db = shift;
		store($db->_curse(), $db->_config('path'));
		$db;
	}

	sub reset
	{
		my $db = shift;
		my $config = $db->_config();
		%$db = ();
		$db->_config($config);
	}

	sub reload
	{
		my $db = shift;
		my $config = $db->_config();
		%$db = %{ _load($db->_config('path')) };
		$db->_config($config);
	}

	use overload '""' => \&stringify;
	sub stringify
	{
		my $db = shift;
		Data::Dumper->Dump([ $db->_curse() ], [ qw(db) ]);
	}

	sub _load
	{
		my $path = shift;
		open my $file, '<', $path or return {};
		fd_retrieve($file);
	}

	sub _curse
	{
		my $db = shift;
		my $cursed = {%$db};
		delete $cursed->{$config_key};
		$cursed;
	}

	sub _config
	{
		my $db = shift;
		my $key = shift;
		if (ref($key) eq 'HASH') {
			$db->{$config_key} = $key;
			return $db;
		}
		return $db->{$config_key}{$key} if $key;
		$db->{$config_key};
	}
}

package main
{
	main();
}

