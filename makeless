#!/usr/bin/perl -w
use strict;

sub main
{
	my $db = database::default(raii::db->new("data"));
	$db->{counter}++;
	print $db->{test}, " -> ", $db->{counter}, "\n";
	print $db, "\n";
}

package database
{
	my $defaults = {
		counter => 0,
		test => "hello world",
	};

	sub default
	{
		my $db = shift;
		my $dvals = shift || $defaults;
		foreach (keys %$dvals) {
			$db->{$_} = $dvals->{$_} unless exists $db->{$_};
			&default($db->{$_}, $dvals->{$_}) if ref($db->{$_}) eq 'HASH'
		}
		$db;
	}

	sub reset
	{
		my $db = shift;
		&default($db->reset())
	}
}

package raii::db
{
	use Storable qw(fd_retrieve store);
	use Data::Dumper;
	$Data::Dumper::Sortkeys = 1;

	my $config_key = 'raii::db::config';

	sub new
	{
		my $class = shift;
		my $path = shift;

		my $db = _load($path);
		bless($db, $class)->_config({ path => $path });
	}

	sub DESTROY
	{
		my $db = shift;
		$db->save();
	}

	sub save
	{
		my $db = shift;
		store($db->_curse(), $db->_config('path'));
		$db;
	}

	sub reset
	{
		my $db = shift;
		my $config = $db->_config();
		%$db = ();
		$db->_config($config);
	}

	sub reload
	{
		my $db = shift;
		my $config = $db->_config();
		%$db = %{ _load($db->_config('path')) };
		$db->_config($config);
	}

	use overload '""' => \&stringify;
	sub stringify
	{
		my $db = shift;
		Data::Dumper->Dump([ $db->_curse() ], [ qw(db) ]);
	}

	sub _load
	{
		my $path = shift;
		open my $file, '<', $path or return {};
		fd_retrieve($file);
	}

	sub _curse
	{
		my $db = shift;
		my $cursed = {%$db};
		delete $cursed->{$config_key};
		$cursed;
	}

	sub _config
	{
		my $db = shift;
		my $key = shift;
		if (ref($key) eq 'HASH') {
			$db->{$config_key} = $key;
			return $db;
		}
		return $db->{$config_key}{$key} if $key;
		$db->{$config_key};
	}
}


package main
{
	main();
}

