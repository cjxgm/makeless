#!/usr/bin/perl
use strict;
use warnings;

sub main
{
	my $db_guard = database->guard();
	my $db = $database::db;

	$db->{counter}++;
	#$db->{debug} = 0;
	#database::reset_files();
	print $db->{test}, " -> ", $db->{counter}, "\n";

	while (my $file = <*>) {
		my $m = database::file_modified($file);
		print "\e[1;32m$file\e[0m: ", ($m ? "\e[1;31mMODIFIED" : "\e[0;35msame"), "\e[0m\n";
	}

	print $db, "\n" if $db->{debug};
}

package database
{
	our $db;

	my $defaults = {
		counter => 0,
		test => "hello world",
		debug => 0,	# 0: no; 1: dump database; 2: 1 with base64 digest
		files => {},
	};

	sub guard
	{
		$db = raii::db->new("data");
		&default();
		bless {}, shift;
	}

	sub DESTROY { undef $db }

	sub default
	{
		my $db = shift || $database::db;
		my $dvals = shift || $defaults;
		foreach (keys %$dvals) {
			$db->{$_} = $dvals->{$_} unless exists $db->{$_};
			&default($db->{$_}, $dvals->{$_}) if ref($db->{$_}) eq 'HASH'
		}
		$db;
	}

	sub reset { &default($db->reset()) }
	sub reset_files { $db->{files} = {} }

	sub file_modified
	{
		my $path = shift;

		# file is assumed to be modified if not recorded in the db.
		# this is for the "first-time" situation.
		unless (exists $db->{files}{$path}) {
			$db->{files}{$path} = {
				digest => file::digest($path),
				time => file::update_time($path),
			};
			return 1;
		}
		my $info = $db->{files}{$path};

		# definitely not modified if timestamp unchanged.
		my $time = $info->{time} || 0;
		my $ftime = file::update_time($path);
		return 0 if $ftime == $time;
		$info->{time} = $ftime;

		# definitely modified if digest changed.
		# TODO: ignore spaces?
		my $digest = $info->{digest} || '';
		my $fdigest = file::digest($path);
		if ($fdigest ne $digest) {
			$info->{digest} = $fdigest;
			return 1;
		}

		# assume not modified.
		# TODO: file content comparison to avoid hash collision?
		#       md5 is pretty good hash function,
		#       so assume collision won't happen for now.
		0;
	}
}

package file
{
	sub update_time
	{
		my $path = shift;
		(stat $path)[9];
	}

	sub digest
	{
		my $path = shift;
		if ($database::db->{debug} > 1) {
			use Digest::file qw(digest_file_base64);
			digest_file_base64($path, "MD5");
		}
		else {
			use Digest::file qw(digest_file);
			digest_file($path, "MD5");
		}
	}
}

package raii::db
{
	use Storable qw(fd_retrieve store);
	use Data::Dumper;
	$Data::Dumper::Indent = 1;
	$Data::Dumper::Useqq = 1;
	$Data::Dumper::Quotekeys = 0;
	$Data::Dumper::Sortkeys = 1;

	my $config_key = 'raii::db::config';

	sub new
	{
		my $class = shift;
		my $path = shift;

		my $db = _load($path);
		bless($db, $class)->_config({ path => $path });
	}

	sub DESTROY
	{
		my $db = shift;
		$db->save();
		print "raii::db -> saved.\n";
	}

	sub save
	{
		my $db = shift;
		store($db->_curse(), $db->_config('path'));
		$db;
	}

	sub reset
	{
		my $db = shift;
		my $config = $db->_config();
		%$db = ();
		$db->_config($config);
	}

	sub reload
	{
		my $db = shift;
		my $config = $db->_config();
		%$db = %{ _load($db->_config('path')) };
		$db->_config($config);
	}

	use overload '""' => \&stringify;
	sub stringify
	{
		my $db = shift;
		Data::Dumper->Dump([ $db->_curse() ], [ qw(db) ]);
	}

	sub _load
	{
		my $path = shift;
		open my $file, '<', $path or return {};
		fd_retrieve($file);
	}

	sub _curse
	{
		my $db = shift;
		my $cursed = {%$db};
		delete $cursed->{$config_key};
		$cursed;
	}

	sub _config
	{
		my $db = shift;
		my $key = shift;
		if (ref($key) eq 'HASH') {
			$db->{$config_key} = $key;
			return $db;
		}
		return $db->{$config_key}{$key} if $key;
		$db->{$config_key};
	}
}

package main
{
	main();
}

