#!/usr/bin/perl
use strict;
use warnings;

# COMMON ABBREVIATIONS
#
# npath    normalized path
# db       database instance
#

sub main
{
	my $options = options::parse();
	my $db_guard = database->guard();
	my $db = $database::db;

	# process options
	my $opt_debug = $options->{debug} || 0;
	if ($db->{debug} != $opt_debug) {
		database::reset_files();
		$db->{debug} = $opt_debug;
		delete $options->{reset};
	}
	database::reset() if $options->{reset};

	# main
	if (!@ARGV && !$db->{last_file}) { options::help(); }
	for (@ARGV) {
		my $file = file::normalize_path($_);
		die "what the heck? $file disappeared?" unless $file;
		makeless::build($file);
		$db->{last_file} = $file;
	}
	makeless::build($db->{last_file}) unless @ARGV;
}

package options
{
	my %available = (
		'reset|r' => "reset the database.",
		'debug|d+' => "enable debugging. "
					. "will reset files when debug options changed from last time.",
		'help|h' => "display this help.",
	);

	sub parse
	{
		use Getopt::Long qw(:config gnu_getopt);

		my $opts = {};
		GetOptions($opts, keys %available) or help(1);
		help() if $opts->{help};
		# TODO: help(1) unless @ARGV;
		$opts;
	}

	sub help
	{
		my $exit_code = shift || 0;

		my @lines;
		push @lines, "=head1 NAME";
		push @lines, "";
		push @lines, "C<makeless>: a config-free C++ build system.";
		push @lines, "";
		push @lines, "=head1 OPTIONS";
		push @lines, "";
		push @lines, "=over";
		push @lines, "";
		for my $k (sort keys %available) {
			my $item = $k;
			for ($item) {
				s{\|}{ | -};
				s{\+$}{, I<multiple leveled>};
			}
			push @lines, "=item --$item";
			push @lines, "";
			push @lines, $available{$k};
			push @lines, "";
		}
		push @lines, "=back";
		push @lines, "";

		use Pod::Text::Color;
		my $p = Pod::Text::Color->new();
		$p->parse_lines(@lines, undef);

		exit $exit_code;
	}
}

package makeless
{
	sub build
	{
		my $npath = shift;
		my $m = database::file_modified($npath);
		print "\e[1;32m$npath\e[0m: ", ($m ? "\e[1;31mMODIFIED" : "\e[0;35msame"), "\e[0m\n";
		database::update_file($npath) if $m;

		#return unless file_dirty($path);
	}

	sub file_dirty
	{
		my $npath = shift;
	}

	sub __is_file_dirty
	{
		my $npath = shift;
	}

	sub __is_module_dirty
	{
		my $npath = shift;
	}
}

package database
{
	our $db;

	my $defaults = {
		debug => 0,	# 0: no; 1: dump database; 2: 1 with base64 digest
		files => {},
		cc => "clang++",
	};

	sub guard
	{
		$db = raii::db->new("data");
		&default();
		bless {}, shift;
	}

	sub DESTROY { undef $db }

	sub default
	{
		my $db = shift || $database::db;
		my $dvals = shift || $defaults;
		for (keys %$dvals) {
			$db->{$_} = $dvals->{$_} unless exists $db->{$_};
			&default($db->{$_}, $dvals->{$_}) if ref($db->{$_}) eq 'HASH'
		}
		$db;
	}

	sub reset { &default($db->reset()) }
	sub reset_files { $db->{files} = {} }

	sub update_file
	{
		my $npath = shift;
		die "is your brain made out of water?" if -d $npath;

		$db->{files}{$npath} = {
			digest => file::digest($npath),
			time => file::update_time($npath),
			dependencies => [],	# TODO
		};
	}

	sub file_modified
	{
		my $npath = shift;

		# file is assumed to be modified if not recorded in the db.
		# this is for the "first-time" situation.
		return 1 unless exists $db->{files}{$npath};
		my $info = $db->{files}{$npath};

		# definitely not modified if timestamp unchanged.
		my $time = $info->{time} || 0;
		my $ftime = file::update_time($npath);
		return 0 if $ftime == $time;

		# definitely modified if digest changed.
		# TODO: ignore spaces?
		my $digest = $info->{digest} || '';
		my $fdigest = file::digest($npath);
		return 1 if $fdigest ne $digest;

		# assume not modified.
		# TODO: file content comparison to avoid hash collision?
		#       md5 is pretty good hash function,
		#       so assume collision won't happen for now.
		0;
	}

	# >> a depends on b, then b affects a.
	# construct affections from dependencies lists
	sub affections
	{
		my $npath = shift;
		my $files = $db->{files};
		my $a = [];
		while (my ($file, $info) = each %$files) {
			for my $dep (@$info->{dependencies}) {
				push @$a, $file if $npath eq $dep;
			}
		}
		$a;
	}

	# fetch dependencies from compiler
	sub _dependencies
	{
		my $path = shift;
		my $cc = $db->{cc};
		my @args = ('-MM', $path);
	}
}

package file
{
	sub update_time
	{
		my $npath = shift;
		(stat $npath)[9];
	}

	sub digest
	{
		my $npath = shift;
		if ($database::db->{debug} > 1) {
			use Digest::file qw(digest_file_base64);
			digest_file_base64($npath, "MD5");
		}
		else {
			use Digest::file qw(digest_file);
			digest_file($npath, "MD5");
		}
	}

	# normalize a relative path to another relative path (relative to cwd)
	# that is consistent enough for comparison and identify same file.
	#
	# examples:
	#   ./a/b/../c/ => a/c
	#   ../a/b/../../../c => ../../c
	#   ../makeless/a => a              # if current directory is     called "makeless"
	#   ../makeless/a => ../makeless/a  # if current directory is NOT called "makeless"
	#
	# this function does physically walking in the filesystem.
	# return undef if file not exist.
	sub normalize_path
	{
		my $path = shift;

		use Cwd qw(abs_path);
		$path = abs_path($path);
		return unless defined $path;

		use File::Spec::Functions qw(abs2rel);
		abs2rel($path);
	}

	sub module_from_path
	{
		for my $npath (shift) {
			die "$npath: not a c++ module" unless m{^(.*)\.(cc|hh)$};
			return $1;
		}
	}

	sub _module_file
	{
		my $module = shift;
		my $suffix = shift;
		my $npath = $module . "." . $suffix;
		return unless -e $npath;
		$npath;
	}

	sub module_header { _module_file(shift, 'hh') }
	sub module_source { _module_file(shift, 'cc') }
}

package raii::db
{
	use Storable qw(fd_retrieve store);
	use Data::Dumper;
	$Data::Dumper::Indent = 1;
	$Data::Dumper::Useqq = 1;
	$Data::Dumper::Quotekeys = 0;
	$Data::Dumper::Sortkeys = 1;

	my $config_key = '__raii::db::config';

	sub new
	{
		my $class = shift;
		my $path = shift;

		my $db = _load($path);
		bless($db, $class)->_config({ path => $path });
	}

	sub DESTROY
	{
		my $db = shift;
		$db->save();
		print "\n\e[1;37m---- DUMP ----\e[0m\n", $db, "\n" if $db->{debug};
	}

	sub save
	{
		my $db = shift;
		store($db->_curse(), $db->_config('path'));
		$db;
	}

	sub reset
	{
		my $db = shift;
		my $config = $db->_config();
		%$db = ();
		$db->_config($config);
	}

	sub reload
	{
		my $db = shift;
		my $config = $db->_config();
		%$db = %{ _load($db->_config('path')) };
		$db->_config($config);
	}

	use overload '""' => \&stringify;
	sub stringify
	{
		my $db = shift;
		Data::Dumper->Dump([ $db->_curse() ], [ qw(db) ]);
	}

	sub _load
	{
		my $path = shift;
		open my $file, '<', $path or return {};
		fd_retrieve($file);
	}

	sub _curse
	{
		my $db = shift;
		my $cursed = {%$db};
		delete $cursed->{$config_key};
		$cursed;
	}

	sub _config
	{
		my $db = shift;
		my $key = shift;
		if (ref($key) eq 'HASH') {
			$db->{$config_key} = $key;
			return $db;
		}
		return $db->{$config_key}{$key} if $key;
		$db->{$config_key};
	}
}

package main
{
	main();
}

