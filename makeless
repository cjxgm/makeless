#!/usr/bin/perl
use strict;
use warnings;

# COMMON ABBREVIATIONS
#
# npath    normalized path
# db       database instance
#

sub main
{
	my $options = options::parse();
	my $db_guard = database->guard();
	my $db = $database::db;

	# process options
	if ($options->{reset}) {
		database::reset();
		exit;
	}
	my $opt_debug = $options->{debug} || 0;
	if ($db->{debug} != $opt_debug) {
		database::reset_files();
		$db->{debug} = $opt_debug;
	}

	# process input files
	my @files;
	if (@ARGV) {
		@files = map { file::normalize_path($_) } @ARGV;
		$db->{triggers} = \@files;
	}
	elsif (exists $db->{triggers}) {}
	else { options::help() }

	my $output = $options->{output} || '/tmp/makeless-build';
	makeless::build($output);

	return unless $options->{execute};
	print "\e[0;32mrunning \e[1;35m$output\e[0m...\n";
	system $output;
	print "\e[0;34mprogram \e[1;35m$output \e[0;34mreturned \e[0m[\e[1;31m", $?>>8, "\e[0m]\n";
}

package makeless
{
	sub build
	{
		my $output = shift;
		my $triggers = $database::db->{triggers};
		my $dirty = $database::db->{dirty};

		# dirty status of all sources and headers
		my %files;
		@files{keys %{database::mark_dirty($_)}} = undef for @$triggers;
		my @files = sort keys %files;

		# dirty status of output
		$dirty->{$output} = undef if %$dirty;
		$dirty->{$output} = undef if database::file_modified($output);

		return unless %$dirty;

		print "\e[0;35mdirty: \e[1;35m$_\e[0m\n" for (sort keys %$dirty);
		database::build_dirty(@files);

		my @objects = grep defined, map { file::source_to_object($_) } @files;
		&link($output, @objects);
		database::update_file($output);
		database::reset_dirty();
	}

	sub compile
	{
		my $path = shift;
		my $cc = $database::db->{cc};
		my $obj = file::source_to_object($path);
		my @args = ('-std=gnu++14', '-c', '-o', $obj, $path);

		print "\e[0;32mcompiling \e[1;35m$path\e[0m...\n";
		system $cc, @args and die "\e[0;31m$path: \e[1;31mfailed to compile.\e[0m";
		$obj;
	}

	sub link
	{
		my $output = shift;
		my $cc = $database::db->{cc};
		my @args = ('-o', $output, @_);

		print "\e[0;32mlinking \e[1;35m$output \e[0;32mfrom \e[0;35m", join(' ', @_), "\e[0m...\n";
		system $cc, @args and die "\e[0;31m$output: \e[1;31mfailed to link.\e[0m";
		$output;
	}
}

package database
{
	our $db;
	our $db_path = ".makeless.db";

	my $defaults = {
		debug => 0,	# 0: no; 1: dump database; 2: 1 with base64 digest
		files => {},
		depss => {},
		dirty => {},
		cc => "clang++",
	};

	sub guard
	{
		$db = raii::db->new($db_path);
		&default();
		bless {}, shift;
	}

	sub DESTROY { undef $db }

	sub default
	{
		my $db = shift || $database::db;
		my $dvals = shift || $defaults;
		for (keys %$dvals) {
			$db->{$_} = $dvals->{$_} unless exists $db->{$_};
			&default($db->{$_}, $dvals->{$_}) if ref($db->{$_}) eq 'HASH'
		}
		$db;
	}

	sub reset { &default($db->reset()) }
	sub reset_files { $db->{files} = {} }
	sub reset_dirty { $db->{dirty} = {} }

	sub update_file
	{
		my $npath = shift;
		die "is your brain made out of water?" if -d $npath;
		if (-e $npath) {
			$db->{files}{$npath} = {
				digest => file::digest($npath),
				modified_time => file::modified_time($npath),
			};
		}
		else {
			delete $db->{files}{$npath};
		}
	}

	sub update_deps
	{
		my $npath = shift;
		die "is your brain made out of water?" if -d $npath;
		$db->{depss}{$npath} = _dependencies($npath);
	}

	sub file_modified
	{
		my $npath = shift;

		# file not exist is considered modified
		return 1 unless -e $npath;

		# file is assumed to be modified if not recorded in the db.
		# this is for the "first-time" situation.
		return 1 unless exists $db->{files}{$npath};
		my $info = $db->{files}{$npath};

		# definitely not modified if modified_time unchanged.
		my $time = $info->{modified_time} || 0;
		my $ftime = file::modified_time($npath);
		return 0 if $ftime == $time;

		# definitely modified if digest changed.
		# TODO: ignore spaces?
		my $digest = $info->{digest} || '';
		my $fdigest = file::digest($npath);
		return 1 if $fdigest ne $digest;

		# assume not modified.
		# TODO: file content comparison to avoid hash collision?
		#       md5 is pretty good hash function,
		#       so assume collision won't happen for now.
		0;
	}

	sub mark_dirty
	{
		my $npath = shift || return;
		my $pending = shift || {};
		my $dirty = $db->{dirty};

		return if exists $pending->{$npath};
		$pending->{$npath} = undef;

		# header
		if (file::is_header($npath)) {
			return unless file_modified($npath);
			update_file($npath);
			$dirty->{$npath} = undef;
			return;
		}

		# source
		if (file_modified($npath)) {
			update_file($npath);
			update_deps($npath);
			$dirty->{$npath} = undef;
		}

		# object
		# TODO: better logic on this?
		my $obj = file::source_to_object($npath);
		if (file_modified($obj)) {
			update_file($obj);
			$dirty->{$npath} = undef;
		}

		# dependencies
		for my $dep (@{$db->{depss}{$npath}}) {
			# header
			mark_dirty($dep, $pending);
			$dirty->{$npath} = undef if exists $dirty->{$dep};

			# source
			mark_dirty(file::header_to_source($dep), $pending);
		}

		$pending;
	}

	sub build_dirty
	{
		my $dirty = $db->{dirty};
		for (@_) {
			next unless exists $dirty->{$_};

			# header
			if (file::is_header($_)) {
				delete $dirty->{$_};
				next;
			}

			# source -> object
			my $obj = makeless::compile($_);
			update_file($obj);
			delete $dirty->{$_};
		}
	}

	# fetch dependencies from compiler
	sub _dependencies
	{
		my $path = shift;
		my $cc = $db->{cc};
		my @args = ('-MM', $path);

		use IPC::Open2;
		my $out;
		my $pid = open2($out, undef, $cc, @args);
		my @deps;
		for (<$out>) {
			chomp;
			s{\s*\\\s*$}{}g;
			while ($_ =~ m{(\\.|[^\\\s])+}g) {
				my $path = $&;
				$path =~ s{\\(.)}{$1}g;
				push @deps, file::normalize_path($path);
			}
		}
		waitpid $pid, 0;
		die "\e[0;31m$path: \e[1;31mcannot obtain dependencies.\e[0m" if $?;
		@deps = @deps[2 .. $#deps];
		return \@deps;
	}
}

package file
{
	sub modified_time
	{
		my $npath = shift;
		(stat $npath)[9];
	}

	sub digest
	{
		my $npath = shift;
		if ($database::db->{debug} > 1) {
			use Digest::file qw(digest_file_base64);
			digest_file_base64($npath, "MD5");
		}
		else {
			use Digest::file qw(digest_file);
			digest_file($npath, "MD5");
		}
	}

	# normalize a relative path to another relative path (relative to cwd)
	# that is consistent enough for comparison and identify same file.
	#
	# examples:
	#   ./a/b/../c/ => a/c
	#   ../a/b/../../../c => ../../c
	#   ../makeless/a => a              # if current directory is     called "makeless"
	#   ../makeless/a => ../makeless/a  # if current directory is NOT called "makeless"
	#
	# this function does physically walking in the filesystem.
	# return undef if file not exist.
	sub normalize_path
	{
		my $path = shift;

		use Cwd qw(abs_path);
		$path = abs_path($path);
		return undef unless defined $path;

		use File::Spec::Functions qw(abs2rel);
		abs2rel($path);
	}

	sub source_to_object
	{
		my $path = shift;
		return undef unless $path =~ s{\.cc$}{.o};
		$path;
	}

	sub is_header
	{
		my $path = shift;
		return undef unless $path =~ m{\.(hh|inl)$};
		$path;
	}

	sub header_to_source
	{
		my $path = shift;
		return undef unless $path =~ s{\.(hh|inl)$}{.cc};
		return undef unless -e $path;
		$path;
	}
}

package options
{
	my %available = (
		'help|h' => "Display this help and exit right away.",
		'reset|r' => "Reset the database, removing all the history cache and settings."
					. " Then default construct a new database."
					. " If you want to remove the database, simply remove the file F<$database::db_path>.",
		'debug|d+' => "Enable debugging. "
					. "Will reset files (i.e. clear cache) when debug options changed from last time.",
		'output|o=s' => "Set default output file for B<current> source.",
		'prefix|p=s' => "B<TODO:> Set build file prefix.",
		'execute|x' => "Execute the built binary.",
		'clean|c+' => "B<TODO:> Clean the built.",
	);

	sub parse
	{
		use Getopt::Long qw(:config gnu_getopt);

		my $opts = {};
		GetOptions($opts, keys %available) or help(1);
		help() if $opts->{help};
		# TODO: help(1) unless @ARGV;
		$opts;
	}

	sub help
	{
		my $exit_code = shift || 0;

		my @lines;
		push @lines, "=head1 NAME";
		push @lines, "";
		push @lines, "C<makeless>: config-free C++ build system";
		push @lines, "";
		push @lines, "=head1 SYNOPSIS";
		push @lines, "";
		push @lines, "B<makeless> [I<OPTIONS>] [F<source-file> [...]]";
		push @lines, "";
		push @lines, "B<ml> [I<OPTIONS>] [F<source-file> [...]]";
		push @lines, "";
		push @lines, "=head1 OPTIONS";
		push @lines, "";
		push @lines, "=over";
		push @lines, "";
		for my $k (sort keys %available) {
			my $item = $k;
			for ($item) {
				s{\|}{ | -};
				s{\+$}{, B<multiple leveled>};
				s{=s$}{ I<string>} and s{ \|}{=I<string>$&};
			}
			push @lines, "=item --$item";
			push @lines, "";
			push @lines, $available{$k};
			push @lines, "";
		}
		push @lines, "=back";
		push @lines, "";

		use Pod::Text::Color;
		my $p = Pod::Text::Color->new();
		$p->parse_lines(@lines, undef);

		exit $exit_code;
	}
}


package raii::db
{
	use Storable qw(fd_retrieve store);
	use Data::Dumper;
	$Data::Dumper::Indent = 1;
	$Data::Dumper::Useqq = 1;
	$Data::Dumper::Quotekeys = 0;
	$Data::Dumper::Sortkeys = 1;

	my $config_key = '__raii::db::config';

	sub new
	{
		my $class = shift;
		my $path = shift;

		my $db = _load($path);
		bless($db, $class)->_config({ path => $path });
	}

	sub DESTROY
	{
		my $db = shift;
		$db->save();
		print "\n\e[1;37m---- DUMP ----\e[0m\n", $db, "\n" if $db->{debug};
	}

	sub save
	{
		my $db = shift;
		store($db->_curse(), $db->_config('path'));
		$db;
	}

	sub reset
	{
		my $db = shift;
		my $config = $db->_config();
		%$db = ();
		$db->_config($config);
	}

	sub reload
	{
		my $db = shift;
		my $config = $db->_config();
		%$db = %{ _load($db->_config('path')) };
		$db->_config($config);
	}

	use overload '""' => \&stringify;
	sub stringify
	{
		my $db = shift;
		Data::Dumper->Dump([ $db->_curse() ], [ qw(db) ]);
	}

	sub _load
	{
		my $path = shift;
		open my $file, '<', $path or return {};
		fd_retrieve($file);
	}

	sub _curse
	{
		my $db = shift;
		my $cursed = {%$db};
		delete $cursed->{$config_key};
		$cursed;
	}

	sub _config
	{
		my $db = shift;
		my $key = shift;
		if (ref($key) eq 'HASH') {
			$db->{$config_key} = $key;
			return $db;
		}
		return $db->{$config_key}{$key} if $key;
		$db->{$config_key};
	}
}

package main
{
	main();
}

